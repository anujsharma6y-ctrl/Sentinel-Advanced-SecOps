import time
from collections import defaultdict

# --- Configuration & Policy Settings ---
# These paths are highly sensitive. Accessing them is a sign of reconnaissance (scouting).
SENSITIVE_PATHS = ["/admin", "/config", "/.env", "/backup.sql"]

# The "Correlation Window" - events must happen within this time frame to be linked.
TIME_WINDOW = 10  # Seconds

# Memory storage: Maps IP addresses to a list of timestamps of their failed login attempts.
failed_logins = defaultdict(list)

def process_auth_event(ip, status):
    """
    Simulates monitoring Authentication Logs (e.g., SSH or Login forms).
    Records failed attempts with a timestamp.
    """
    if status == "fail":
        # Record the exact time of the failure
        failed_logins[ip].append(time.time())
        print(f"‚ö†Ô∏è  [Auth Log] Failed login attempt detected from IP: {ip}")

def process_web_event(ip, path):
    """
    Simulates monitoring Web Server Logs (e.g., Apache or Nginx).
    Correlates web activity with previous authentication failures.
    """
    current_time = time.time()

    # Step 1: Check if the IP has a history of failures in our memory
    if ip in failed_logins:
        
        # Step 2: Temporal Correlation
        # Filter the list to keep ONLY failures that happened within the last 10 seconds.
        recent_failures = [t for t in failed_logins[ip] if current_time - t < TIME_WINDOW]
        
        # Update the memory to remove old, irrelevant timestamps
        failed_logins[ip] = recent_failures

        # Step 3: Pattern Matching
        # If the IP has 3+ recent failures AND is now touching sensitive files...
        if len(recent_failures) >= 3 and path in SENSITIVE_PATHS:
            print("\n" + "!"*60)
            print(f"üö® [CORRELATION ALERT] MULTI-STAGE ATTACK DETECTED!")
            print(f"üïµÔ∏è  Attacker IP: {ip}")
            print(f"üìù Pattern Identified: Brute-force + Sensitive Directory Probing")
            print(f"üéØ Target Resource: {path}")
            print(f"‚è±Ô∏è  Time Span: {len(recent_failures)} events within last {TIME_WINDOW}s")
            print("!"*60 + "\n")
            # In a real system, you would call a function to block the IP here.

    print(f"üåê [Web Log] Standard access to {path} by {ip}")

# --- Execution Simulation ---
if __name__ == "__main__":
    print("üõ°Ô∏è  Sentinel L-IDS: Initializing Multi-Log Correlation Engine...\n")

    # ATTACK SIMULATION:
    # Stage 1: Attacker tries to crack the password (3 failed attempts)
    attacker_ip = "192.168.1.50"
    process_auth_event(attacker_ip, "fail")
    process_auth_event(attacker_ip, "fail")
    process_auth_event(attacker_ip, "fail")

    # Small delay to simulate real-world traffic
    time.sleep(1)

    # Stage 2: Attacker immediately tries to steal the environment configuration file
    process_web_event(attacker_ip, "/.env")

    # Normal User Simulation:
    process_web_event("10.0.0.5", "/home/index.html")
